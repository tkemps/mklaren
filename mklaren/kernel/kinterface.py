import numpy
from numpy import array, atleast_2d, ndarray, diag, sqrt, outer
from scipy.sparse import isspmatrix


class Kinterface:
        """
        Interface to invoke kernels. Acts as a wrapper for a unified use of
        kernel functions/matrices by implementing ``__getitem__`` and ``__call__``.

        Required for methods that only require access to parts
        of the kernel matrix.
        """

        def __init__(self, data, kernel, kernel_args={}, data_labels=None, row_normalize=False):
            """
            :param data: (``numpy.ndarray```) Data in the original input space.

            :param kernel: (``callable``) Kernel function.

            :param kernel_args: (``dict``) Dictionary of kernel hyperparameters (``**kwargs``).

            :param data_labels: (``list``) Data labels.

            :param row_normalize (``bool``) Normalize matrix diagonal to equal a vector of 1s.
            """
            self.data   = data
            self.kernel = kernel
            self.kernel_args = kernel_args
            try:
                self.shape  = (len(data), len(data))
            except TypeError:
                self.shape  = (data.shape[0], data.shape[0])
            self.data_labels = data_labels
            self.row_normalize = row_normalize

        def __getitem__(self, item):
            """
            Access portions of the kernel matrix generated by ``kernel``.

            :param item: (``tuple``) pair of: indices or list of indices or (``numpy.ndarray``) or (``slice``) to address portions of the kernel matrix.

            :return:  (``numpy.ndarray``) Value of the kernel matrix for item.
            """
            assert isinstance(item, tuple)
            assert len(item) == 2
            args = [None, None]
            for oi, obj in enumerate(item):
                if isinstance(obj, int) or isinstance(obj, numpy.integer):
                    assert obj >= 0
                    args[oi] = self.data[obj]
                    if isinstance(args[oi], ndarray):
                        args[oi] = atleast_2d(args[oi])
                elif isinstance(obj, slice):
                    start = obj.start if obj.start is not None else 0
                    stop  = obj.stop if obj.stop is not None else self.shape[0]
                    assert start >= 0
                    assert stop >= 0
                    args[oi] = self.data[start:stop]
                elif isinstance(obj, range) or isinstance(obj, list) or \
                    isinstance(obj, ndarray):
                    if isinstance(obj, ndarray) and len(obj.shape) > 1:
                        # Assume items represent data not indices
                        args[oi] = obj
                    elif isinstance(self.data, list):
                        args[oi] = [self.data[int(o)] for o in obj]
                    else:
                        args[oi] = self.data[list(map(int, obj))]

                elif isspmatrix(obj):
                    args[oi] = obj

                else:
                    raise NotImplementedError("Unknown addressing type: "+str(type.mro(type(obj))))

            # Ravel if vector
            # r = self.kernel(args[0], args[1], **self.kernel_args)
            r = self.__call__(args[0], args[1])
            if hasattr(r, "shape") and 1 in r.shape:
                r = r.ravel()
            return r

        def __call__(self, x, y):
            """
            Mimic a callable kernel function.

            :param x: (``numpy.ndarray``) Data point.

            :param y: (``numpy.ndarray``) Data point.

            :return:  (``float``) Value of the kernel for x, y.
            """
            K = self.kernel(x, y, **self.kernel_args)
            if self.row_normalize:
                x_norm = diag(self.kernel(x, x, **self.kernel_args))
                y_norm = diag(self.kernel(y, y, **self.kernel_args))
                K = K / sqrt(outer(x_norm, y_norm))
            return K

        def diag(self):
            """
            Diagonal of the kernel matrix.

            .. math::
                \mathbf{d}_i = k(\mathbf{x}_i, \mathbf{x}_i)

            :return (``numpy.ndarray``) diagonal values of the kernel matrix.
            """
            return array([self[i, i] for i in range(self.shape[0])]).ravel()

        def diagonal(self):
            """ Diagonal of the kernel matrix (alias). """
            return self.diag()
